#!/usr/bin/env python3
"""
Confcomments: Export Confluence page comments to readable Markdown

Usage:
    confcomments PAGE_ID [OUTPUT_FILE]
    confcomments PAGE_ID > comments.md

Environment variables required:
    CONFLUENCE_DOMAIN    Your Atlassian domain (e.g., "company.atlassian.net")
    CONFLUENCE_EMAIL     Your Confluence email
    CONFLUENCE_TOKEN     Your Confluence API token
"""

import argparse
import base64
import json
import os
import sys
import urllib.error
import urllib.parse
import urllib.request
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional


# ============================================================================
# Global verbose flag
# ============================================================================

VERBOSE = False

def log(msg: str) -> None:
    """Print message only in verbose mode."""
    if VERBOSE:
        print(msg, file=sys.stderr)


# ============================================================================
# Configuration
# ============================================================================

def get_config() -> tuple[str, str, str]:
    """Load Confluence configuration from environment variables."""
    required = {
        "CONFLUENCE_DOMAIN": os.getenv("CONFLUENCE_DOMAIN"),
        "CONFLUENCE_EMAIL": os.getenv("CONFLUENCE_EMAIL"),
        "CONFLUENCE_TOKEN": os.getenv("CONFLUENCE_TOKEN")
    }
    
    missing = [k for k, v in required.items() if not v]
    if missing:
        print(f"Missing environment variables: {', '.join(missing)}\n", file=sys.stderr)
        print("Set them in your environment:", file=sys.stderr)
        print('  export CONFLUENCE_DOMAIN="your-domain.atlassian.net"', file=sys.stderr)
        print('  export CONFLUENCE_EMAIL="your.email@company.com"', file=sys.stderr)
        print('  export CONFLUENCE_TOKEN="your_api_token"', file=sys.stderr)
        print("\nGet API token at: https://id.atlassian.com/manage-profile/security/api-tokens", file=sys.stderr)
        sys.exit(1)

    return required["CONFLUENCE_DOMAIN"], required["CONFLUENCE_EMAIL"], required["CONFLUENCE_TOKEN"]


# ============================================================================
# Confluence API Client
# ============================================================================

def api_request(domain: str, email: str, token: str, path: str, 
                method: str = "GET", data: Optional[Dict[str, Any]] = None,
                params: Optional[Dict[str, str]] = None) -> Dict[str, Any]:
    """Make HTTP request to Confluence API."""
    url = f"https://{domain}/wiki{path}"
    if params:
        url = f"{url}?{urllib.parse.urlencode(params)}"
    
    # Build headers
    auth = base64.b64encode(f"{email}:{token}".encode()).decode()
    headers = {"Authorization": f"Basic {auth}", "Accept": "application/json"}
    if data:
        headers["Content-Type"] = "application/json"
    
    # Build request
    request_data = json.dumps(data).encode("utf-8") if data else None
    req = urllib.request.Request(url, data=request_data, headers=headers, method=method)
    
    # Execute request with error handling
    try:
        with urllib.request.urlopen(req) as response:
            return json.loads(response.read().decode("utf-8"))
    except urllib.error.HTTPError as e:
        error_body = e.read().decode("utf-8") if e.fp else ""
        print(f"API request failed (HTTP {e.code}): {e.reason}", file=sys.stderr)
        if error_body:
            print(f"Response: {error_body[:1000]}", file=sys.stderr)
        sys.exit(1)
    except urllib.error.URLError as e:
        print(f"Network error: {e.reason}", file=sys.stderr)
        sys.exit(1)


# ============================================================================
# Comment Extraction and Formatting
# ============================================================================

def extract_text_from_adf(adf_node: Any) -> str:
    """Recursively extract plain text from ADF (Atlassian Document Format) nodes."""
    if isinstance(adf_node, dict):
        node_type = adf_node.get("type")
        
        # Text node - return the text content
        if node_type == "text":
            return adf_node.get("text", "")
        
        # Inline nodes that should preserve their content
        if node_type in ["mention", "emoji", "hardBreak"]:
            if node_type == "mention":
                return f"@{adf_node.get('attrs', {}).get('text', 'user')}"
            elif node_type == "emoji":
                return adf_node.get("attrs", {}).get("shortName", "")
            elif node_type == "hardBreak":
                return "\n"
        
        # Recursively process content
        if "content" in adf_node:
            texts = [extract_text_from_adf(child) for child in adf_node["content"]]
            
            # Add spacing for block-level elements
            if node_type in ["paragraph", "heading", "listItem"]:
                return " ".join(texts) + "\n"
            else:
                return "".join(texts)
        
        return ""
    
    elif isinstance(adf_node, list):
        return "".join(extract_text_from_adf(item) for item in adf_node)
    
    return str(adf_node) if adf_node else ""


def format_comment(comment: Dict[str, Any], indent: int = 0, show_resolved: bool = True) -> str:
    """Format a single comment with metadata in markdown."""
    indent_str = "  " * indent
    
    # Skip resolved comments if not showing them
    status = comment.get("status", "active")
    if not show_resolved and status == "resolved":
        return ""
    
    # Extract comment metadata
    author = comment.get("version", {}).get("by", {}).get("displayName", "Unknown")
    created = comment.get("version", {}).get("when", "")
    comment_id = comment.get("id", "")
    
    # Format timestamp
    timestamp = ""
    if created:
        try:
            dt = datetime.fromisoformat(created.replace("Z", "+00:00"))
            timestamp = dt.strftime("%Y-%m-%d %H:%M")
        except:
            timestamp = created
    
    # Status indicator
    status_marker = " [RESOLVED]" if status == "resolved" else ""
    
    # Extract comment body text
    body = comment.get("body", {})
    if body.get("atlas_doc_format"):
        # Parse ADF and extract text
        try:
            adf_content = json.loads(body["atlas_doc_format"]["value"])
            comment_text = extract_text_from_adf(adf_content).strip()
        except:
            comment_text = body.get("view", {}).get("value", "")
    else:
        comment_text = body.get("view", {}).get("value", "")
    
    # Extract inline comment context (highlighted text)
    inline_context = ""
    extensions = comment.get("extensions", {})
    
    if "inlineProperties" in extensions:
        inline_props = extensions["inlineProperties"]
        original_selection = inline_props.get("originalSelection", "")
        if original_selection:
            inline_context = f"{indent_str}**Context:** \"{original_selection}\"\n\n"
    
    # Build the markdown output
    output = []
    output.append(f"{indent_str}### Comment by {author}{status_marker}")
    output.append(f"{indent_str}*{timestamp}*\n")
    
    if inline_context:
        output.append(inline_context)
    
    # Format comment text with proper indentation
    for line in comment_text.split("\n"):
        if line.strip():
            output.append(f"{indent_str}{line}")
    
    output.append("")  # Blank line after comment
    
    return "\n".join(output)


def format_comment_thread(comment: Dict[str, Any], all_comments: List[Dict[str, Any]], 
                         processed: set, indent: int = 0, show_resolved: bool = True) -> str:
    """Format a comment and its replies recursively."""
    comment_id = comment.get("id", "")
    
    # Skip if already processed
    if comment_id in processed:
        return ""
    
    processed.add(comment_id)
    
    # Format this comment
    output = [format_comment(comment, indent, show_resolved)]
    
    # Find and format replies (children)
    for other_comment in all_comments:
        parent_id = other_comment.get("extensions", {}).get("location", "")
        # Check if this comment is a reply to the current comment
        if parent_id == f"comment-{comment_id}":
            reply_output = format_comment_thread(other_comment, all_comments, processed, 
                                                indent + 1, show_resolved)
            if reply_output:
                output.append(reply_output)
    
    return "\n".join(output)


def fetch_all_comments(domain: str, email: str, token: str, page_id: str) -> List[Dict[str, Any]]:
    """Fetch all comments for a page, handling pagination."""
    all_comments = []
    start = 0
    limit = 100
    
    while True:
        log(f"Fetching comments (start={start})...")
        response = api_request(
            domain, email, token,
            f"/rest/api/content/{page_id}/child/comment",
            params={
                "expand": "body.atlas_doc_format,body.view,version,extensions.inlineProperties",
                "start": str(start),
                "limit": str(limit)
            }
        )
        
        results = response.get("results", [])
        all_comments.extend(results)
        
        # Check if there are more comments
        links = response.get("_links", {})
        if "next" not in links:
            break
        
        start += limit
    
    return all_comments


def export_comments(page_id: str, output_file: Optional[str] = None, 
                   show_resolved: bool = True) -> None:
    """Export all comments from a Confluence page to markdown."""
    domain, email, token = get_config()
    
    # Get page title
    log(f"Fetching page {page_id}...")
    page_data = api_request(
        domain, email, token,
        f"/rest/api/content/{page_id}",
        params={"expand": "title,version"}
    )
    
    page_title = page_data.get("title", "Untitled")
    page_version = page_data.get("version", {}).get("number", "?")
    
    log(f"Page: {page_title} (v{page_version})")
    
    # Fetch all comments
    all_comments = fetch_all_comments(domain, email, token, page_id)
    log(f"Found {len(all_comments)} total comments")
    
    if not all_comments:
        print(f"No comments found on page {page_id}", file=sys.stderr)
        sys.exit(0)
    
    # Build markdown output
    output = []
    output.append(f"# Comments: {page_title}\n")
    output.append(f"*Page ID: {page_id} | Version: {page_version}*\n")
    output.append(f"*Exported: {datetime.now().strftime('%Y-%m-%d %H:%M')}*\n")
    output.append("---\n")
    
    # Find top-level comments (not replies)
    processed = set()
    top_level_comments = []
    
    for comment in all_comments:
        # A top-level comment either has no location or location is not a comment
        location = comment.get("extensions", {}).get("location", "")
        if not location or not location.startswith("comment-"):
            top_level_comments.append(comment)
    
    log(f"Found {len(top_level_comments)} top-level comments")
    
    # Format each comment thread
    for comment in top_level_comments:
        thread_output = format_comment_thread(comment, all_comments, processed, 
                                            indent=0, show_resolved=show_resolved)
        if thread_output:
            output.append(thread_output)
            output.append("\n---\n")  # Separator between threads
    
    markdown_output = "\n".join(output)
    
    # Write output
    if output_file:
        Path(output_file).write_text(markdown_output, encoding="utf-8")
        print(f"Wrote {len(top_level_comments)} comment threads to: {output_file}", file=sys.stderr)
    else:
        sys.stdout.write(markdown_output)


# ============================================================================
# Main CLI
# ============================================================================

def main():
    """Main CLI entry point."""
    parser = argparse.ArgumentParser(
        description="Confcomments: Export Confluence page comments to Markdown",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s 123456789 comments.md      # Export to file
  %(prog)s 123456789 > comments.md    # Export to stdout
  %(prog)s 123456789 --hide-resolved  # Hide resolved comments

Environment variables required:
  CONFLUENCE_DOMAIN    Your Atlassian domain (e.g., "company.atlassian.net")
  CONFLUENCE_EMAIL     Your Confluence email
  CONFLUENCE_TOKEN     Your Confluence API token

Get API token at: https://id.atlassian.com/manage-profile/security/api-tokens
        """,
    )
    
    parser.add_argument("page_id", help="Confluence page ID")
    parser.add_argument("file", nargs="?", help="Output markdown file (optional, defaults to stdout)")
    parser.add_argument("-v", "--verbose", action="store_true", 
                       help="Show detailed progress messages")
    parser.add_argument("--hide-resolved", action="store_true",
                       help="Hide resolved comments from output")
    
    args = parser.parse_args()
    
    # Set global verbose flag
    global VERBOSE
    VERBOSE = args.verbose
    
    try:
        export_comments(args.page_id, args.file, show_resolved=not args.hide_resolved)
    except KeyboardInterrupt:
        print("\nCancelled", file=sys.stderr)
        sys.exit(130)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        if VERBOSE:
            import traceback
            traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()

